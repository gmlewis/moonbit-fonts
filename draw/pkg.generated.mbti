// Generated using `moon info`, DON'T EDIT IT
package "gmlewis/fonts/draw"

import(
  "gmlewis/fonts"
  "moonbitlang/core/json"
)

// Values
pub fn bbox(Double, Double, Double, Double) -> BoundingBox

pub fn fill(Color) -> Fill

pub fn group(Array[Graphic]) -> Group

pub fn rgba(Double, Double, Double, Double) -> Color

pub fn stroke(Color) -> Stroke

pub fn text(text~ : String, font~ : @fonts.Font, align? : TextAlign, size? : Double) -> Graphic raise DrawError

pub fn unit_circle() -> Group

pub fn unit_square() -> Group

pub fn vec2(Double, Double) -> Vec2

// Errors
pub(all) suberror DrawError String
pub impl Eq for DrawError
pub impl Show for DrawError

// Types and methods
pub(all) struct AffineMatrix {
  mut a : Double
  mut b : Double
  mut c : Double
  mut d : Double
  mut tx : Double
  mut ty : Double
}
pub fn AffineMatrix::clone(Self) -> Self
pub fn AffineMatrix::copy(Self, Self) -> Self
pub fn AffineMatrix::determinant(Self) -> Double
pub fn AffineMatrix::from_center_scale(Vec2, Vec2) -> Self
pub fn AffineMatrix::from_rotation(Double) -> Self
pub fn AffineMatrix::from_scale(Vec2) -> Self
pub fn AffineMatrix::from_scale_scalar(Double) -> Self
pub fn AffineMatrix::from_transform(Transform) -> Self
pub fn AffineMatrix::from_translation(Vec2) -> Self
pub fn AffineMatrix::from_translation_points(Vec2, Vec2) -> Self
pub fn AffineMatrix::invert(Self) -> Self
pub fn AffineMatrix::is_identity(Self) -> Bool
pub fn AffineMatrix::is_inf(Self) -> Bool
pub fn AffineMatrix::is_invertible(Self) -> Bool
pub fn AffineMatrix::is_mirror(Self) -> Bool
pub fn AffineMatrix::is_nan(Self) -> Bool
pub fn AffineMatrix::is_orthogonal(Self, tolerance? : Double) -> Bool
pub fn AffineMatrix::is_uniform_scale(Self, tolerance? : Double) -> Bool
pub fn AffineMatrix::mul_without_translation(Self, Self) -> Self
pub fn AffineMatrix::new(a? : Double, b? : Double, c? : Double, d? : Double, tx? : Double, ty? : Double) -> Self
pub fn AffineMatrix::normalize(Self) -> Self
pub fn AffineMatrix::origin(Self, Vec2) -> Self
pub fn AffineMatrix::pre_mul(Self, Self) -> Self
pub fn AffineMatrix::pre_mul_without_translation(Self, Self) -> Self
pub fn AffineMatrix::rotate(Self, Double) -> Self
pub fn AffineMatrix::scale(Self, Vec2) -> Self
pub fn AffineMatrix::scale_scalar(Self, Double) -> Self
pub fn AffineMatrix::self_mul(Self, Self) -> Self
pub fn AffineMatrix::skew(Self, Double) -> Self
pub fn AffineMatrix::to_transform(Self, origin? : Vec2) -> Transform
pub fn AffineMatrix::translate(Self, Vec2) -> Self
pub impl Eq for AffineMatrix
pub impl Mul for AffineMatrix
pub impl Show for AffineMatrix

pub(all) struct Anchor {
  mut position : Vec2
  mut handle_in : Vec2
  mut handle_out : Vec2
}
pub fn Anchor::affine_transform(Self, AffineMatrix) -> Self
pub fn Anchor::affine_transform_without_translation(Self, AffineMatrix) -> Self
pub fn Anchor::all_anchors(Self) -> Array[Self]
pub fn Anchor::bounding_box(Self) -> BoundingBox?
pub fn Anchor::clone(Self) -> Self
pub fn Anchor::closest_point(Self, Vec2, area_of_interest? : BoundingBox) -> Vec2?
pub fn Anchor::has_tangent_handles(Self, tolerance? : Double) -> Bool
pub fn Anchor::has_zero_handles(Self) -> Bool
pub fn Anchor::is_contained_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Anchor::is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Anchor::is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Anchor::loose_bounding_box(Self) -> BoundingBox?
pub fn Anchor::new(position? : Vec2, handle_in? : Vec2, handle_out? : Vec2) -> Self
pub fn Anchor::reverse(Self) -> Self
pub fn Anchor::transform(Self, position? : Vec2, rotation? : Double, scale? : Vec2, skew? : Double, origin? : Vec2) -> Self
pub impl Eq for Anchor
pub impl Show for Anchor
pub impl ToJson for Anchor
pub impl @json.FromJson for Anchor

pub(all) struct BoundingBox {
  mut min : Vec2
  mut max : Vec2
}
pub fn BoundingBox::area(Self) -> Double
pub fn BoundingBox::boolean_intersect(Self, Array[Self]) -> Self?
pub fn BoundingBox::canonicalize(Self) -> Self
pub fn BoundingBox::center(Self) -> Vec2
pub fn BoundingBox::clone(Self) -> Self
pub fn BoundingBox::contains_bounding_box(Self, Self) -> Bool
pub fn BoundingBox::contains_point(Self, Vec2) -> Bool
pub fn BoundingBox::expand_scalar(Self, Double) -> Self
pub fn BoundingBox::expand_to_include_bounding_box(Self, Self) -> Self
pub fn BoundingBox::expand_to_include_point(Self, Vec2) -> Self
pub fn BoundingBox::from_points(Array[Vec2]) -> Self
pub fn BoundingBox::height(Self) -> Double
pub fn BoundingBox::is_inf(Self) -> Bool
pub fn BoundingBox::is_nan(Self) -> Bool
pub fn BoundingBox::max_reversed() -> Self
pub fn BoundingBox::new(min? : Vec2, max? : Vec2) -> Self
pub fn BoundingBox::overlaps_bounding_box(Self, Self) -> Bool
pub fn BoundingBox::size(Self) -> Vec2
pub fn BoundingBox::width(Self) -> Double
pub impl Eq for BoundingBox
pub impl Show for BoundingBox

pub(all) struct Color {
  mut r : Double
  mut g : Double
  mut b : Double
  mut a : Double
}
pub fn Color::as_fill(Self) -> Fill?
pub fn Color::clone(Self) -> Self
pub fn Color::from_css_string(String) -> Self raise
pub fn Color::from_hsva(Double, Double, Double, Double) -> Self
pub fn Color::from_rgb8_number(UInt) -> Self
pub fn Color::luminance(Self) -> Double
pub fn Color::mix(Self, Self, Double) -> Self
pub fn Color::new(r? : Double, g? : Double, b? : Double, a? : Double) -> Self
pub fn Color::set(Self, Double, Double, Double, Double) -> Self
pub fn Color::to_css_hex_string(Self) -> String
pub fn Color::to_css_rgba_string(Self) -> String
pub fn Color::to_css_string(Self) -> String
pub fn Color::to_hsva(Self) -> Array[Double]
pub fn Color::to_rgb8_number(Self) -> UInt
pub impl Eq for Color
pub impl Show for Color
pub impl ToJson for Color
pub impl @json.FromJson for Color

pub(all) struct CompoundPath {
  mut paths : Array[Path]
  mut fill : Fill?
  mut stroke : Stroke?
}
pub fn CompoundPath::affine_transform(Self, AffineMatrix) -> Self
pub fn CompoundPath::affine_transform_without_translation(Self, AffineMatrix) -> Self
pub fn CompoundPath::all_anchors(Self) -> Array[Anchor]
pub fn CompoundPath::as_graphic(Self) -> Graphic
pub fn CompoundPath::assign_fill(Self, Fill?) -> Self
pub fn CompoundPath::assign_stroke(Self, Stroke?) -> Self
pub fn CompoundPath::assign_style(Self, Fill?, Stroke?) -> Self
pub fn CompoundPath::bounding_box(Self) -> BoundingBox?
pub fn CompoundPath::clone(Self) -> Self
pub fn CompoundPath::closest_point(Self, Vec2, BoundingBox?) -> Anchor?
pub fn CompoundPath::contains_point(Self, Vec2) -> Bool
pub fn CompoundPath::copy_style(Self, Graphic) -> Self
pub fn CompoundPath::first_styled(Self) -> Graphic?
pub fn CompoundPath::has_style(Self) -> Bool
pub fn CompoundPath::is_contained_by_bounding_box(Self, BoundingBox) -> Bool
pub fn CompoundPath::is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
pub fn CompoundPath::is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
pub fn CompoundPath::loose_bounding_box(Self) -> BoundingBox?
pub fn CompoundPath::new(paths? : Array[Path], fill? : Fill, stroke? : Stroke) -> Self
pub fn CompoundPath::op_get(Self, Int) -> Path
pub fn CompoundPath::op_set(Self, Int, Path) -> Unit
pub fn CompoundPath::primitives(Self) -> Array[Graphic]
pub fn CompoundPath::remove_fill(Self) -> Self
pub fn CompoundPath::remove_stroke(Self) -> Self
pub fn CompoundPath::reverse(Self) -> Self
pub fn CompoundPath::rotate(Self, Double) -> Self
pub fn CompoundPath::scale(Self, Vec2) -> Self
pub fn CompoundPath::scale_stroke(Self, Double) -> Self
pub fn CompoundPath::style_contains_point(Self, Vec2) -> Bool
pub fn CompoundPath::transform(Self, position? : Vec2, rotation? : Double, scale? : Vec2, skew? : Double, origin? : Vec2) -> Self
pub fn CompoundPath::translate(Self, Vec2) -> Self
pub impl Show for CompoundPath
pub impl ToJson for CompoundPath
pub impl @json.FromJson for CompoundPath

pub(all) struct Fill {
  color : Color
}
pub fn Fill::new(color? : Color) -> Self
pub impl Clonable for Fill
pub impl Eq for Fill
pub impl Show for Fill
pub impl ToJson for Fill
pub impl @json.FromJson for Fill

pub(all) enum Graphic {
  CompoundPath(CompoundPath)
  Group(Group)
  Path(Path)
}
pub fn Graphic::affine_transform(Self, AffineMatrix) -> Self
pub fn Graphic::affine_transform_without_translation(Self, AffineMatrix) -> Self
pub fn Graphic::all_anchors(Self) -> Array[Anchor]
pub fn Graphic::all_compound_paths(Self) -> Array[CompoundPath]
pub fn Graphic::all_paths(Self) -> Array[Path]
pub fn Graphic::all_paths_and_compound_paths(Self) -> Array[Self]
pub fn Graphic::assign_fill(Self, Fill?) -> Self
pub fn Graphic::assign_stroke(Self, Stroke?) -> Self
pub fn Graphic::assign_style(Self, Fill?, Stroke?) -> Self
pub fn Graphic::bounding_box(Self) -> BoundingBox?
pub fn Graphic::clone(Self) -> Self
pub fn Graphic::closest_point(Self, Vec2, BoundingBox?) -> Anchor?
pub fn Graphic::contains_point(Vec2) -> (Self) -> Bool
pub fn Graphic::copy_style(Self, Self) -> Self
pub fn Graphic::every(Array[Self], (Self) -> Bool) -> Bool
pub fn Graphic::first_fill(Self) -> Fill?
pub fn Graphic::first_stroke(Self) -> Stroke?
pub fn Graphic::first_styled(Self) -> Self?
pub fn Graphic::fit_to(Self, BoundingBox) -> Self
pub fn Graphic::has_style(Self) -> Bool
pub fn Graphic::is_contained_by_bounding_box(BoundingBox) -> (Self) -> Bool
pub fn Graphic::is_intersected_by_bounding_box(BoundingBox) -> (Self) -> Bool
pub fn Graphic::is_overlapped_by_bounding_box(BoundingBox) -> (Self) -> Bool
pub fn Graphic::loose_bounding_box(Self) -> BoundingBox?
pub fn Graphic::primitives(Self) -> Array[Self]
pub fn Graphic::remove_fill(Self) -> Self
pub fn Graphic::remove_stroke(Self) -> Self
pub fn Graphic::reverse(Self) -> Self
pub fn Graphic::rotate(Self, Double) -> Self
pub fn Graphic::scale(Self, Vec2) -> Self
pub fn Graphic::scale_stroke(Self, Double) -> Self
pub fn Graphic::some(Array[Self], (Self) -> Bool) -> Bool
pub fn Graphic::style_contains_point(Vec2) -> (Self) -> Bool
pub fn Graphic::transform(Self, position? : Vec2, rotation? : Double, scale? : Vec2, skew? : Double, origin? : Vec2) -> Self
pub fn Graphic::translate(Self, Vec2) -> Self
pub impl Show for Graphic
pub impl ToJson for Graphic
pub impl @json.FromJson for Graphic

pub(all) struct Group {
  mut items : Array[Graphic]
}
pub fn Group::affine_transform(Self, AffineMatrix) -> Self
pub fn Group::affine_transform_without_translation(Self, AffineMatrix) -> Self
pub fn Group::all_anchors(Self) -> Array[Anchor]
pub fn Group::all_compound_paths(Self) -> Array[CompoundPath]
pub fn Group::all_paths(Self) -> Array[Path]
pub fn Group::all_paths_and_compound_paths(Self) -> Array[Graphic]
pub fn Group::as_graphic(Self) -> Graphic
pub fn Group::assign_fill(Self, Fill?) -> Self
pub fn Group::assign_stroke(Self, Stroke?) -> Self
pub fn Group::assign_style(Self, Fill?, Stroke?) -> Self
pub fn Group::bounding_box(Self) -> BoundingBox?
pub fn Group::clone(Self) -> Self
pub fn Group::closest_point(Self, Vec2, BoundingBox?) -> Anchor?
pub fn Group::contains_point(Self, Vec2) -> Bool
pub fn Group::copy_style(Self, Graphic) -> Self
pub fn Group::first_fill(Self) -> Fill?
pub fn Group::first_stroke(Self) -> Stroke?
pub fn Group::first_styled(Self) -> Graphic?
pub fn Group::has_style(Self) -> Bool
pub fn Group::is_contained_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Group::is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Group::is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Group::loose_bounding_box(Self) -> BoundingBox?
pub fn Group::new(items? : Array[Graphic]) -> Self
pub fn Group::op_get(Self, Int) -> Graphic
pub fn Group::op_set(Self, Int, Graphic) -> Unit
pub fn Group::primitives(Self) -> Array[Graphic]
pub fn Group::remove_fill(Self) -> Self
pub fn Group::remove_stroke(Self) -> Self
pub fn Group::reverse(Self) -> Self
pub fn Group::rotate(Self, Double) -> Self
pub fn Group::scale(Self, Vec2) -> Self
pub fn Group::scale_stroke(Self, Double) -> Self
pub fn Group::style_contains_point(Self, Vec2) -> Bool
pub fn Group::transform(Self, position? : Vec2, rotation? : Double, scale? : Vec2, skew? : Double, origin? : Vec2) -> Self
pub fn Group::translate(Self, Vec2) -> Self
pub impl Show for Group
pub impl ToJson for Group
pub impl @json.FromJson for Group

pub(all) struct Path {
  mut anchors : Array[Anchor]
  mut closed : Bool
  mut clear : Bool
  mut fill : Fill?
  mut stroke : Stroke?
}
pub fn Path::affine_transform(Self, AffineMatrix) -> Self
pub fn Path::affine_transform_without_translation(Self, AffineMatrix) -> Self
pub fn Path::as_graphic(Self) -> Graphic
pub fn Path::assign_fill(Self, Fill?) -> Self
pub fn Path::assign_stroke(Self, Stroke?) -> Self
pub fn Path::assign_style(Self, Fill?, Stroke?) -> Self
pub fn Path::bounding_box(Self) -> BoundingBox?
pub fn Path::clone(Self) -> Self
pub fn Path::closest_point(Self, Vec2, BoundingBox?) -> Anchor?
pub fn Path::contains_point(Self, Vec2) -> Bool
pub fn Path::copy_style(Self, Graphic) -> Self
pub fn Path::first_styled(Self) -> Graphic?
pub fn Path::from_points(Array[Vec2], closed? : Bool) -> Self
pub fn Path::has_style(Self) -> Bool
pub fn Path::is_contained_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Path::is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Path::is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
pub fn Path::loose_bounding_box(Self) -> BoundingBox?
pub fn Path::new(anchors? : Array[Anchor], closed? : Bool, clear? : Bool, fill? : Fill, stroke? : Stroke) -> Self
pub fn Path::op_get(Self, Int) -> Anchor
pub fn Path::op_set(Self, Int, Anchor) -> Unit
pub fn Path::primitives(Self) -> Array[Graphic]
pub fn Path::remove_fill(Self) -> Self
pub fn Path::remove_stroke(Self) -> Self
pub fn Path::reverse(Self) -> Self
pub fn Path::rotate(Self, Double) -> Self
pub fn Path::scale(Self, Vec2) -> Self
pub fn Path::scale_stroke(Self, Double) -> Self
pub fn Path::style_contains_point(Self, Vec2) -> Bool
pub fn Path::transform(Self, position? : Vec2, rotation? : Double, scale? : Vec2, skew? : Double, origin? : Vec2) -> Self
pub fn Path::translate(Self, Vec2) -> Self
pub impl Show for Path
pub impl ToJson for Path
pub impl @json.FromJson for Path

pub(all) struct Stroke {
  mut color : Color
  mut width : Double
  mut alignment : StrokeAlignment
  mut cap : StrokeCap
  mut join : StrokeJoin
  mut miter_limit : Double
}
pub fn Stroke::new(color? : Color, width? : Double, alignment? : StrokeAlignment, cap? : StrokeCap, join? : StrokeJoin, miter_limit? : Double) -> Self
pub impl Clonable for Stroke
pub impl Eq for Stroke
pub impl Show for Stroke
pub impl ToJson for Stroke
pub impl @json.FromJson for Stroke

pub(all) enum StrokeAlignment {
  Centered
  Inner
  Outer
}
pub impl Eq for StrokeAlignment
pub impl Show for StrokeAlignment
pub impl ToJson for StrokeAlignment
pub impl @json.FromJson for StrokeAlignment

pub(all) enum StrokeCap {
  Butt
  Round
  Square
}
pub impl Eq for StrokeCap
pub impl Show for StrokeCap
pub impl ToJson for StrokeCap
pub impl @json.FromJson for StrokeCap

pub(all) enum StrokeJoin {
  Miter
  Round
  Bevel
}
pub impl Eq for StrokeJoin
pub impl Show for StrokeJoin
pub impl ToJson for StrokeJoin
pub impl @json.FromJson for StrokeJoin

pub(all) enum TextAlign {
  Left
  Center
  Right
}
pub impl Eq for TextAlign
pub impl Show for TextAlign

pub(all) struct Transform {
  position : Vec2
  rotation : Double
  scale : Vec2
  skew : Double
  origin : Vec2
}
pub fn Transform::new(position? : Vec2, rotation? : Double, scale? : Vec2, skew? : Double, origin? : Vec2) -> Self
pub impl Eq for Transform
pub impl Show for Transform

pub(all) struct Vec2 {
  mut x : Double
  mut y : Double
}
pub fn Vec2::affine_transform(Self, AffineMatrix) -> Self
pub fn Vec2::affine_transform_without_translation(Self, AffineMatrix) -> Self
pub fn Vec2::almost_equals(Self, Self, tolerance? : Double) -> Bool
pub fn Vec2::angle(Self) -> Double
pub fn Vec2::angle_radians(Self) -> Double
pub fn Vec2::apply(Self, (Double) -> Double) -> Self
pub fn Vec2::ceil(Self) -> Self
pub fn Vec2::clone(Self) -> Self
pub fn Vec2::copy(Self, Self) -> Self
pub fn Vec2::cross(Self, Self) -> Double
pub fn Vec2::distance(Self, Self) -> Double
pub fn Vec2::distance_squared(Self, Self) -> Double
pub fn Vec2::dot(Self, Self) -> Double
pub fn Vec2::floor(Self) -> Self
pub fn Vec2::from_angle(Double) -> Self
pub fn Vec2::from_angle_radians(Double) -> Self
pub fn Vec2::infinity() -> Self
pub fn Vec2::is_clockwise_from(Self, Self) -> Bool
pub fn Vec2::is_inf(Self) -> Bool
pub fn Vec2::is_nan(Self) -> Bool
pub fn Vec2::is_valid(Self) -> Bool
pub fn Vec2::is_zero(Self) -> Bool
pub fn Vec2::length(Self) -> Double
pub fn Vec2::length_squared(Self) -> Double
pub fn Vec2::max(Self, Self) -> Self
pub fn Vec2::min(Self, Self) -> Self
pub fn Vec2::mix(Self, Self, Double) -> Self
pub fn Vec2::neg_infinity() -> Self
pub fn Vec2::negate(Self) -> Self
pub fn Vec2::new(x? : Double, y? : Double) -> Self
pub fn Vec2::normalize(Self) -> Self
pub fn Vec2::project_onto(Self, Self) -> Self
pub fn Vec2::rotate(Self, Double) -> Self
pub fn Vec2::rotate90(Self) -> Self
pub fn Vec2::rotate_neg90(Self) -> Self
pub fn Vec2::rotate_radians(Self, Double) -> Self
pub fn Vec2::round(Self) -> Self
pub fn Vec2::round_to_fixed(Self, Int) -> Self
pub fn Vec2::round_to_multiple(Self, Double) -> Self
pub fn Vec2::self_add(Self, Self) -> Self
pub fn Vec2::self_add_scalar(Self, Double) -> Self
pub fn Vec2::self_div(Self, Self) -> Self
pub fn Vec2::self_div_scalar(Self, Double) -> Self
pub fn Vec2::self_mul(Self, Self) -> Self
pub fn Vec2::self_mul_scalar(Self, Double) -> Self
pub fn Vec2::self_sub(Self, Self) -> Self
pub fn Vec2::self_sub_scalar(Self, Double) -> Self
pub fn Vec2::set(Self, Double, Double) -> Self
pub fn Vec2::transform(Self, position? : Self, rotation? : Double, scale? : Self, skew? : Double, origin? : Self) -> Self
pub impl Add for Vec2
pub impl Div for Vec2
pub impl Eq for Vec2
pub impl Mul for Vec2
pub impl Neg for Vec2
pub impl Show for Vec2
pub impl Sub for Vec2
pub impl ToJson for Vec2
pub impl @json.FromJson for Vec2

// Type aliases

// Traits
pub(open) trait Clonable {
  clone(Self) -> Self
}


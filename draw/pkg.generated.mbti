// Generated using `moon info`, DON'T EDIT IT
package "gmlewis/fonts/draw"

import(
  "gmlewis/fonts"
  "gmlewis/fonts/geom"
  "moonbitlang/core/json"
)

// Values
pub fn bbox(Double, Double, Double, Double) -> @geom.BoundingBox

pub fn cubic_bezier_at(@geom.Vec2, @geom.Vec2, @geom.Vec2, @geom.Vec2, Double) -> @geom.Vec2

pub fn dedupe_points(Array[@geom.Vec2], epsilon? : Double) -> Array[@geom.Vec2]

pub fn fill(Color) -> Fill

pub fn group(Array[Graphic]) -> Group

pub fn rgba(Double, Double, Double, Double) -> Color

pub fn stroke(Color) -> Stroke

pub fn text(@fonts.Font, String, size? : Double, align? : TextAlign) -> Graphic raise DrawError

pub fn to_graphic(@fonts.Font, String, size? : Double, alignment? : @geom.Alignment) -> Graphic raise DrawError

pub fn unit_circle() -> Group

pub fn unit_square() -> Group

pub fn vec2(Double, Double) -> @geom.Vec2

// Errors
pub(all) suberror DrawError String
pub impl Eq for DrawError
pub impl Show for DrawError

// Types and methods
pub(all) struct Anchor {
  mut position : @geom.Vec2
  mut handle_in : @geom.Vec2
  mut handle_out : @geom.Vec2
}
pub fn Anchor::affine_transform(Self, @geom.AffineMatrix) -> Self
pub fn Anchor::affine_transform_without_translation(Self, @geom.AffineMatrix) -> Self
pub fn Anchor::all_anchors(Self) -> Array[Self]
pub fn Anchor::bounding_box(Self) -> @geom.BoundingBox?
pub fn Anchor::clone(Self) -> Self
pub fn Anchor::closest_point(Self, @geom.Vec2, area_of_interest? : @geom.BoundingBox) -> @geom.Vec2?
pub fn Anchor::has_tangent_handles(Self, tolerance? : Double) -> Bool
pub fn Anchor::has_zero_handles(Self) -> Bool
pub fn Anchor::is_contained_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Anchor::is_intersected_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Anchor::is_overlapped_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Anchor::loose_bounding_box(Self) -> @geom.BoundingBox?
pub fn Anchor::new(position? : @geom.Vec2, handle_in? : @geom.Vec2, handle_out? : @geom.Vec2) -> Self
pub fn Anchor::reverse(Self) -> Self
pub fn Anchor::transform(Self, position? : @geom.Vec2, rotation? : Double, scale? : @geom.Vec2, skew? : Double, origin? : @geom.Vec2) -> Self
pub impl Eq for Anchor
pub impl Show for Anchor
pub impl ToJson for Anchor
pub impl @json.FromJson for Anchor

pub(all) struct Color {
  mut r : Double
  mut g : Double
  mut b : Double
  mut a : Double
}
pub fn Color::as_fill(Self) -> Fill?
pub fn Color::black() -> Self
pub fn Color::blue() -> Self
pub fn Color::clone(Self) -> Self
pub fn Color::from_css_string(String) -> Self raise
pub fn Color::from_hsva(Double, Double, Double, Double) -> Self
pub fn Color::from_rgb8_number(UInt) -> Self
pub fn Color::green() -> Self
pub fn Color::luminance(Self) -> Double
pub fn Color::mix(Self, Self, Double) -> Self
pub fn Color::new(r? : Double, g? : Double, b? : Double, a? : Double) -> Self
pub fn Color::red() -> Self
pub fn Color::set(Self, Double, Double, Double, Double) -> Self
pub fn Color::to_css_hex_string(Self) -> String
pub fn Color::to_css_rgba_string(Self) -> String
pub fn Color::to_css_string(Self) -> String
pub fn Color::to_hsva(Self) -> Array[Double]
pub fn Color::to_rgb8_number(Self) -> UInt
pub fn Color::transparent() -> Self
pub fn Color::white() -> Self
pub impl Eq for Color
pub impl Show for Color
pub impl ToJson for Color
pub impl @json.FromJson for Color

pub(all) struct CompoundPath {
  mut paths : Array[Path]
  mut fill : Fill?
  mut stroke : Stroke?
}
pub fn CompoundPath::affine_transform(Self, @geom.AffineMatrix) -> Self
pub fn CompoundPath::affine_transform_without_translation(Self, @geom.AffineMatrix) -> Self
pub fn CompoundPath::all_anchors(Self) -> Array[Anchor]
pub fn CompoundPath::as_graphic(Self) -> Graphic
pub fn CompoundPath::assign_fill(Self, Fill?) -> Self
pub fn CompoundPath::assign_stroke(Self, Stroke?) -> Self
pub fn CompoundPath::assign_style(Self, Fill?, Stroke?) -> Self
pub fn CompoundPath::bounding_box(Self) -> @geom.BoundingBox?
pub fn CompoundPath::clone(Self) -> Self
pub fn CompoundPath::closest_point(Self, @geom.Vec2, @geom.BoundingBox?) -> Anchor?
pub fn CompoundPath::contains_point(Self, @geom.Vec2) -> Bool
pub fn CompoundPath::copy_style(Self, Graphic) -> Self
pub fn CompoundPath::first_styled(Self) -> Graphic?
pub fn CompoundPath::has_style(Self) -> Bool
pub fn CompoundPath::is_contained_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn CompoundPath::is_intersected_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn CompoundPath::is_overlapped_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn CompoundPath::loose_bounding_box(Self) -> @geom.BoundingBox?
pub fn CompoundPath::new(paths? : Array[Path], fill? : Fill, stroke? : Stroke) -> Self
pub fn CompoundPath::op_get(Self, Int) -> Path
pub fn CompoundPath::op_set(Self, Int, Path) -> Unit
pub fn CompoundPath::primitives(Self) -> Array[Graphic]
pub fn CompoundPath::remove_fill(Self) -> Self
pub fn CompoundPath::remove_stroke(Self) -> Self
pub fn CompoundPath::reverse(Self) -> Self
pub fn CompoundPath::rotate(Self, Double) -> Self
pub fn CompoundPath::scale(Self, @geom.Vec2) -> Self
pub fn CompoundPath::scale_stroke(Self, Double) -> Self
pub fn CompoundPath::style_contains_point(Self, @geom.Vec2) -> Bool
pub fn CompoundPath::transform(Self, position? : @geom.Vec2, rotation? : Double, scale? : @geom.Vec2, skew? : Double, origin? : @geom.Vec2) -> Self
pub fn CompoundPath::translate(Self, @geom.Vec2) -> Self
pub impl Show for CompoundPath
pub impl ToJson for CompoundPath
pub impl @json.FromJson for CompoundPath

pub(all) struct Fill {
  color : Color
}
pub fn Fill::from_string(String) -> Self raise
pub fn Fill::new(color? : Color) -> Self
pub impl Clonable for Fill
pub impl Eq for Fill
pub impl Show for Fill
pub impl ToJson for Fill
pub impl @json.FromJson for Fill

pub(all) enum Graphic {
  CompoundPath(CompoundPath)
  Group(Group)
  Path(Path)
}
pub fn Graphic::affine_transform(Self, @geom.AffineMatrix) -> Self
pub fn Graphic::affine_transform_without_translation(Self, @geom.AffineMatrix) -> Self
pub fn Graphic::all_anchors(Self) -> Array[Anchor]
pub fn Graphic::all_compound_paths(Self) -> Array[CompoundPath]
pub fn Graphic::all_paths(Self) -> Array[Path]
pub fn Graphic::all_paths_and_compound_paths(Self) -> Array[Self]
pub fn Graphic::assign_fill(Self, Fill?) -> Self
pub fn Graphic::assign_stroke(Self, Stroke?) -> Self
pub fn Graphic::assign_style(Self, Fill?, Stroke?) -> Self
pub fn Graphic::bounding_box(Self) -> @geom.BoundingBox?
pub fn Graphic::clone(Self) -> Self
pub fn Graphic::closest_point(Self, @geom.Vec2, @geom.BoundingBox?) -> Anchor?
pub fn Graphic::contains_point(@geom.Vec2) -> (Self) -> Bool
pub fn Graphic::copy_style(Self, Self) -> Self
pub fn Graphic::every(Array[Self], (Self) -> Bool) -> Bool
pub fn Graphic::first_fill(Self) -> Fill?
pub fn Graphic::first_stroke(Self) -> Stroke?
pub fn Graphic::first_styled(Self) -> Self?
pub fn Graphic::fit_to(Self, @geom.BoundingBox, anchor? : @geom.Alignment) -> Self
pub fn Graphic::has_style(Self) -> Bool
pub fn Graphic::is_contained_by_bounding_box(@geom.BoundingBox) -> (Self) -> Bool
pub fn Graphic::is_intersected_by_bounding_box(@geom.BoundingBox) -> (Self) -> Bool
pub fn Graphic::is_overlapped_by_bounding_box(@geom.BoundingBox) -> (Self) -> Bool
pub fn Graphic::loose_bounding_box(Self) -> @geom.BoundingBox?
pub fn Graphic::primitives(Self) -> Array[Self]
pub fn Graphic::remove_fill(Self) -> Self
pub fn Graphic::remove_stroke(Self) -> Self
pub fn Graphic::reverse(Self) -> Self
pub fn Graphic::rotate(Self, Double) -> Self
pub fn Graphic::scale(Self, @geom.Vec2) -> Self
pub fn Graphic::scale_stroke(Self, Double) -> Self
pub fn Graphic::scale_to_fill(Self, @geom.BoundingBox) -> Self
pub fn Graphic::scale_to_fit(Self, @geom.BoundingBox, anchor? : @geom.Alignment) -> Self
pub fn Graphic::some(Array[Self], (Self) -> Bool) -> Bool
pub fn Graphic::style_contains_point(@geom.Vec2) -> (Self) -> Bool
pub fn Graphic::to_profiles(Self, Int) -> Array[(Array[@geom.Vec2], Array[Array[@geom.Vec2]])]
pub fn Graphic::to_profiles_tuples(Self, Int) -> Array[(Array[(Double, Double)], Array[Array[(Double, Double)]])]
pub fn Graphic::transform(Self, position? : @geom.Vec2, rotation? : Double, scale? : @geom.Vec2, skew? : Double, origin? : @geom.Vec2) -> Self
pub fn Graphic::translate(Self, @geom.Vec2) -> Self
pub fn Graphic::with_style(Self, fill? : Fill, stroke? : Stroke) -> Self
pub impl Add for Graphic
pub impl Show for Graphic
pub impl ToJson for Graphic
pub impl @json.FromJson for Graphic

pub(all) struct Group {
  mut items : Array[Graphic]
}
pub fn Group::affine_transform(Self, @geom.AffineMatrix) -> Self
pub fn Group::affine_transform_without_translation(Self, @geom.AffineMatrix) -> Self
pub fn Group::all_anchors(Self) -> Array[Anchor]
pub fn Group::all_compound_paths(Self) -> Array[CompoundPath]
pub fn Group::all_paths(Self) -> Array[Path]
pub fn Group::all_paths_and_compound_paths(Self) -> Array[Graphic]
pub fn Group::as_graphic(Self) -> Graphic
pub fn Group::assign_fill(Self, Fill?) -> Self
pub fn Group::assign_stroke(Self, Stroke?) -> Self
pub fn Group::assign_style(Self, Fill?, Stroke?) -> Self
pub fn Group::bounding_box(Self) -> @geom.BoundingBox?
pub fn Group::clone(Self) -> Self
pub fn Group::closest_point(Self, @geom.Vec2, @geom.BoundingBox?) -> Anchor?
pub fn Group::contains_point(Self, @geom.Vec2) -> Bool
pub fn Group::copy_style(Self, Graphic) -> Self
pub fn Group::first_fill(Self) -> Fill?
pub fn Group::first_stroke(Self) -> Stroke?
pub fn Group::first_styled(Self) -> Graphic?
pub fn Group::has_style(Self) -> Bool
pub fn Group::is_contained_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Group::is_intersected_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Group::is_overlapped_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Group::loose_bounding_box(Self) -> @geom.BoundingBox?
pub fn Group::new(items? : Array[Graphic]) -> Self
pub fn Group::op_get(Self, Int) -> Graphic
pub fn Group::op_set(Self, Int, Graphic) -> Unit
pub fn Group::primitives(Self) -> Array[Graphic]
pub fn Group::remove_fill(Self) -> Self
pub fn Group::remove_stroke(Self) -> Self
pub fn Group::reverse(Self) -> Self
pub fn Group::rotate(Self, Double) -> Self
pub fn Group::scale(Self, @geom.Vec2) -> Self
pub fn Group::scale_stroke(Self, Double) -> Self
pub fn Group::self_transform(Self, position? : @geom.Vec2, rotation? : Double, scale? : @geom.Vec2, skew? : Double, origin? : @geom.Vec2) -> Unit
pub fn Group::style_contains_point(Self, @geom.Vec2) -> Bool
pub fn Group::transform(Self, position? : @geom.Vec2, rotation? : Double, scale? : @geom.Vec2, skew? : Double, origin? : @geom.Vec2) -> Self
pub fn Group::translate(Self, @geom.Vec2) -> Self
pub impl Show for Group
pub impl ToJson for Group
pub impl @json.FromJson for Group

pub(all) struct Path {
  mut anchors : Array[Anchor]
  mut closed : Bool
  mut clear : Bool
  mut fill : Fill?
  mut stroke : Stroke?
}
pub fn Path::affine_transform(Self, @geom.AffineMatrix) -> Self
pub fn Path::affine_transform_without_translation(Self, @geom.AffineMatrix) -> Self
pub fn Path::as_graphic(Self) -> Graphic
pub fn Path::assign_fill(Self, Fill?) -> Self
pub fn Path::assign_stroke(Self, Stroke?) -> Self
pub fn Path::assign_style(Self, Fill?, Stroke?) -> Self
pub fn Path::bounding_box(Self) -> @geom.BoundingBox?
pub fn Path::clone(Self) -> Self
pub fn Path::closest_point(Self, @geom.Vec2, @geom.BoundingBox?) -> Anchor?
pub fn Path::contains_point(Self, @geom.Vec2) -> Bool
pub fn Path::copy_style(Self, Graphic) -> Self
pub fn Path::first_styled(Self) -> Graphic?
pub fn Path::from_points(Array[@geom.Vec2], closed? : Bool) -> Self
pub fn Path::has_style(Self) -> Bool
pub fn Path::is_contained_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Path::is_intersected_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Path::is_overlapped_by_bounding_box(Self, @geom.BoundingBox) -> Bool
pub fn Path::loose_bounding_box(Self) -> @geom.BoundingBox?
pub fn Path::new(anchors? : Array[Anchor], closed? : Bool, clear? : Bool, fill? : Fill, stroke? : Stroke) -> Self
pub fn Path::op_get(Self, Int) -> Anchor
pub fn Path::op_set(Self, Int, Anchor) -> Unit
pub fn Path::primitives(Self) -> Array[Graphic]
pub fn Path::remove_fill(Self) -> Self
pub fn Path::remove_stroke(Self) -> Self
pub fn Path::reverse(Self) -> Self
pub fn Path::rotate(Self, Double) -> Self
pub fn Path::scale(Self, @geom.Vec2) -> Self
pub fn Path::scale_stroke(Self, Double) -> Self
pub fn Path::style_contains_point(Self, @geom.Vec2) -> Bool
pub fn Path::to_polygon(Self, Int, epsilon? : Double) -> Array[@geom.Vec2]
pub fn Path::transform(Self, position? : @geom.Vec2, rotation? : Double, scale? : @geom.Vec2, skew? : Double, origin? : @geom.Vec2) -> Self
pub fn Path::translate(Self, @geom.Vec2) -> Self
pub impl Show for Path
pub impl ToJson for Path
pub impl @json.FromJson for Path

pub(all) struct Stroke {
  mut color : Color
  mut width : Double
  mut alignment : StrokeAlignment
  mut cap : StrokeCap
  mut join : StrokeJoin
  mut miter_limit : Double
}
pub fn Stroke::new(color? : Color, width? : Double, alignment? : StrokeAlignment, cap? : StrokeCap, join? : StrokeJoin, miter_limit? : Double) -> Self
pub impl Clonable for Stroke
pub impl Eq for Stroke
pub impl Show for Stroke
pub impl ToJson for Stroke
pub impl @json.FromJson for Stroke

pub(all) enum StrokeAlignment {
  Centered
  Inner
  Outer
}
pub impl Eq for StrokeAlignment
pub impl Show for StrokeAlignment
pub impl ToJson for StrokeAlignment
pub impl @json.FromJson for StrokeAlignment

pub(all) enum StrokeCap {
  Butt
  Round
  Square
}
pub impl Eq for StrokeCap
pub impl Show for StrokeCap
pub impl ToJson for StrokeCap
pub impl @json.FromJson for StrokeCap

pub(all) enum StrokeJoin {
  Miter
  Round
  Bevel
}
pub impl Eq for StrokeJoin
pub impl Show for StrokeJoin
pub impl ToJson for StrokeJoin
pub impl @json.FromJson for StrokeJoin

pub(all) enum TextAlign {
  Left
  Center
  Right
}
pub impl Eq for TextAlign
pub impl Show for TextAlign

// Type aliases
pub using @fonts {type AbsoluteCmd}

pub using @geom {type AffineMatrix}

pub using @geom {type Alignment}

pub using @geom {type BoundingBox}

pub using @fonts {type Font}

pub using @fonts {type GerberLP}

pub using @fonts {type Glyph}

pub using @fonts {type PathCmd}

pub using @fonts {type SVGPath}

pub using @geom {type Transform}

pub using @geom {type Vec2}

// Traits
pub(open) trait Clonable {
  clone(Self) -> Self
}


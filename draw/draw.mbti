package gmlewis/fonts/draw

alias @gmlewis/fonts as @fonts
alias @moonbitlang/core/json as @json

// Values
fn bbox(Double, Double, Double, Double) -> BoundingBox

fn fill(Color) -> Fill

fn group(Array[Graphic]) -> Group

fn rgba(Double, Double, Double, Double) -> Color

fn stroke(Color) -> Stroke

fn text(text~ : String, font~ : @fonts.Font, align~ : TextAlign = .., size~ : Double = ..) -> Graphic!DrawError

fn unit_circle() -> Group

fn unit_square() -> Group

fn vec2(Double, Double) -> Vec2

// Types and methods
pub(all) struct AffineMatrix {
  a : Double
  b : Double
  c : Double
  d : Double
  tx : Double
  ty : Double
}
impl AffineMatrix {
  clone(Self) -> Self
  copy(Self, Self) -> Self
  determinant(Self) -> Double
  from_center_scale(Vec2, Vec2) -> Self
  from_rotation(Double) -> Self
  from_scale(Vec2) -> Self
  from_scale_scalar(Double) -> Self
  from_transform(Transform) -> Self
  from_translation(Vec2) -> Self
  from_translation_points(Vec2, Vec2) -> Self
  invert(Self) -> Self
  is_identity(Self) -> Bool
  is_inf(Self) -> Bool
  is_invertible(Self) -> Bool
  is_mirror(Self) -> Bool
  is_nan(Self) -> Bool
  is_orthogonal(Self, tolerance~ : Double = ..) -> Bool
  is_uniform_scale(Self, tolerance~ : Double = ..) -> Bool
  mul(Self, Self) -> Self
  mul_without_translation(Self, Self) -> Self
  new(a~ : Double = .., b~ : Double = .., c~ : Double = .., d~ : Double = .., tx~ : Double = .., ty~ : Double = ..) -> Self
  normalize(Self) -> Self
  op_mul(Self, Self) -> Self
  origin(Self, Vec2) -> Self
  pre_mul(Self, Self) -> Self
  pre_mul_without_translation(Self, Self) -> Self
  rotate(Self, Double) -> Self
  scale(Self, Vec2) -> Self
  scale_scalar(Self, Double) -> Self
  skew(Self, Double) -> Self
  to_transform(Self, origin~ : Vec2 = ..) -> Transform
  translate(Self, Vec2) -> Self
}
impl Eq for AffineMatrix
impl Show for AffineMatrix

pub(all) struct Anchor {
  position : Vec2
  handle_in : Vec2
  handle_out : Vec2
}
impl Anchor {
  affine_transform(Self, AffineMatrix) -> Self
  affine_transform_without_translation(Self, AffineMatrix) -> Self
  all_anchors(Self) -> Array[Self]
  bounding_box(Self) -> BoundingBox?
  clone(Self) -> Self
  closest_point(Self, Vec2, area_of_interest? : BoundingBox) -> Vec2?
  has_tangent_handles(Self, tolerance~ : Double = ..) -> Bool
  has_zero_handles(Self) -> Bool
  is_contained_by_bounding_box(Self, BoundingBox) -> Bool
  is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
  is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
  loose_bounding_box(Self) -> BoundingBox?
  new(position~ : Vec2 = .., handle_in~ : Vec2 = .., handle_out~ : Vec2 = ..) -> Self
  reverse(Self) -> Self
  transform(Self, position~ : Vec2 = .., rotation~ : Double = .., scale~ : Vec2 = .., skew~ : Double = .., origin~ : Vec2 = ..) -> Self
}
impl Eq for Anchor
impl Show for Anchor
impl ToJson for Anchor
impl @json.FromJson for Anchor

pub(all) struct BoundingBox {
  min : Vec2
  max : Vec2
}
impl BoundingBox {
  area(Self) -> Double
  boolean_intersect(Self, Array[Self]) -> Self?
  canonicalize(Self) -> Self
  center(Self) -> Vec2
  clone(Self) -> Self
  contains_bounding_box(Self, Self) -> Bool
  contains_point(Self, Vec2) -> Bool
  expand_scalar(Self, Double) -> Self
  expand_to_include_bounding_box(Self, Self) -> Self
  expand_to_include_point(Self, Vec2) -> Self
  from_points(Array[Vec2]) -> Self
  height(Self) -> Double
  is_inf(Self) -> Bool
  is_nan(Self) -> Bool
  max_reversed() -> Self
  new(min~ : Vec2 = .., max~ : Vec2 = ..) -> Self
  overlaps_bounding_box(Self, Self) -> Bool
  size(Self) -> Vec2
  width(Self) -> Double
}
impl Eq for BoundingBox
impl Show for BoundingBox

pub(all) struct Color {
  r : Double
  g : Double
  b : Double
  a : Double
}
impl Color {
  as_fill(Self) -> Fill?
  clone(Self) -> Self
  from_css_string(String) -> Self!
  from_hsva(Double, Double, Double, Double) -> Self
  from_rgb8_number(UInt) -> Self
  luminance(Self) -> Double
  mix(Self, Self, Double) -> Self
  new(r~ : Double = .., g~ : Double = .., b~ : Double = .., a~ : Double = ..) -> Self
  set(Self, Double, Double, Double, Double) -> Self
  to_css_hex_string(Self) -> String
  to_css_rgba_string(Self) -> String
  to_css_string(Self) -> String
  to_hsva(Self) -> Array[Double]
  to_rgb8_number(Self) -> UInt
}
impl Eq for Color
impl Show for Color
impl ToJson for Color
impl @json.FromJson for Color

pub(all) struct CompoundPath {
  paths : Array[Path]
  fill : Fill?
  stroke : Stroke?
}
impl CompoundPath {
  affine_transform(Self, AffineMatrix) -> Self
  affine_transform_without_translation(Self, AffineMatrix) -> Self
  all_anchors(Self) -> Array[Anchor]
  as_graphic(Self) -> Graphic
  assign_fill(Self, Fill?) -> Self
  assign_stroke(Self, Stroke?) -> Self
  assign_style(Self, Fill?, Stroke?) -> Self
  bounding_box(Self) -> BoundingBox?
  clone(Self) -> Self
  closest_point(Self, Vec2, BoundingBox?) -> Anchor?
  contains_point(Self, Vec2) -> Bool
  copy_style(Self, Graphic) -> Self
  first_styled(Self) -> Graphic?
  has_style(Self) -> Bool
  is_contained_by_bounding_box(Self, BoundingBox) -> Bool
  is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
  is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
  loose_bounding_box(Self) -> BoundingBox?
  new(paths~ : Array[Path] = .., fill~ : Fill? = .., stroke~ : Stroke? = ..) -> Self
  op_get(Self, Int) -> Path
  op_set(Self, Int, Path) -> Unit
  primitives(Self) -> Array[Graphic]
  remove_fill(Self) -> Self
  remove_stroke(Self) -> Self
  reverse(Self) -> Self
  rotate(Self, Double) -> Self
  scale(Self, Vec2) -> Self
  scale_stroke(Self, Double) -> Self
  style_contains_point(Self, Vec2) -> Bool
  transform(Self, position~ : Vec2 = .., rotation~ : Double = .., scale~ : Vec2 = .., skew~ : Double = .., origin~ : Vec2 = ..) -> Self
  translate(Self, Vec2) -> Self
}
impl Show for CompoundPath
impl ToJson for CompoundPath
impl @json.FromJson for CompoundPath

pub(all) type! DrawError String
impl Eq for DrawError
impl Show for DrawError

pub(all) struct Fill {
  color : Color
}
impl Fill {
  clone(Self) -> Self
  new(color~ : Color = ..) -> Self
}
impl Eq for Fill
impl Show for Fill
impl ToJson for Fill
impl @json.FromJson for Fill

pub(all) enum Graphic {
  CompoundPath(CompoundPath)
  Group(Group)
  Path(Path)
}
impl Graphic {
  affine_transform(Self, AffineMatrix) -> Self
  affine_transform_without_translation(Self, AffineMatrix) -> Self
  all_anchors(Self) -> Array[Anchor]
  all_compound_paths(Self) -> Array[CompoundPath]
  all_paths(Self) -> Array[Path]
  all_paths_and_compound_paths(Self) -> Array[Self]
  assign_fill(Self, Fill?) -> Self
  assign_stroke(Self, Stroke?) -> Self
  assign_style(Self, Fill?, Stroke?) -> Self
  bounding_box(Self) -> BoundingBox?
  clone(Self) -> Self
  closest_point(Self, Vec2, BoundingBox?) -> Anchor?
  contains_point(Vec2) -> (Self) -> Bool
  copy_style(Self, Self) -> Self
  every(Array[Self], (Self) -> Bool) -> Bool
  first_fill(Self) -> Fill?
  first_stroke(Self) -> Stroke?
  first_styled(Self) -> Self?
  fit_to(Self, BoundingBox) -> Self
  has_style(Self) -> Bool
  is_contained_by_bounding_box(BoundingBox) -> (Self) -> Bool
  is_intersected_by_bounding_box(BoundingBox) -> (Self) -> Bool
  is_overlapped_by_bounding_box(BoundingBox) -> (Self) -> Bool
  loose_bounding_box(Self) -> BoundingBox?
  primitives(Self) -> Array[Self]
  remove_fill(Self) -> Self
  remove_stroke(Self) -> Self
  reverse(Self) -> Self
  rotate(Self, Double) -> Self
  scale(Self, Vec2) -> Self
  scale_stroke(Self, Double) -> Self
  some(Array[Self], (Self) -> Bool) -> Bool
  style_contains_point(Vec2) -> (Self) -> Bool
  to_json(Self) -> Json
  transform(Self, position~ : Vec2 = .., rotation~ : Double = .., scale~ : Vec2 = .., skew~ : Double = .., origin~ : Vec2 = ..) -> Self
  translate(Self, Vec2) -> Self
}
impl Show for Graphic
impl @json.FromJson for Graphic

pub(all) struct Group {
  items : Array[Graphic]
}
impl Group {
  affine_transform(Self, AffineMatrix) -> Self
  affine_transform_without_translation(Self, AffineMatrix) -> Self
  all_anchors(Self) -> Array[Anchor]
  all_compound_paths(Self) -> Array[CompoundPath]
  all_paths(Self) -> Array[Path]
  all_paths_and_compound_paths(Self) -> Array[Graphic]
  as_graphic(Self) -> Graphic
  assign_fill(Self, Fill?) -> Self
  assign_stroke(Self, Stroke?) -> Self
  assign_style(Self, Fill?, Stroke?) -> Self
  bounding_box(Self) -> BoundingBox?
  clone(Self) -> Self
  closest_point(Self, Vec2, BoundingBox?) -> Anchor?
  contains_point(Self, Vec2) -> Bool
  copy_style(Self, Graphic) -> Self
  first_fill(Self) -> Fill?
  first_stroke(Self) -> Stroke?
  first_styled(Self) -> Graphic?
  has_style(Self) -> Bool
  is_contained_by_bounding_box(Self, BoundingBox) -> Bool
  is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
  is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
  loose_bounding_box(Self) -> BoundingBox?
  new(items~ : Array[Graphic] = ..) -> Self
  op_get(Self, Int) -> Graphic
  op_set(Self, Int, Graphic) -> Unit
  primitives(Self) -> Array[Graphic]
  remove_fill(Self) -> Self
  remove_stroke(Self) -> Self
  reverse(Self) -> Self
  rotate(Self, Double) -> Self
  scale(Self, Vec2) -> Self
  scale_stroke(Self, Double) -> Self
  style_contains_point(Self, Vec2) -> Bool
  transform(Self, position~ : Vec2 = .., rotation~ : Double = .., scale~ : Vec2 = .., skew~ : Double = .., origin~ : Vec2 = ..) -> Self
  translate(Self, Vec2) -> Self
}
impl Show for Group
impl ToJson for Group
impl @json.FromJson for Group

pub(all) struct Path {
  anchors : Array[Anchor]
  closed : Bool
  clear : Bool
  fill : Fill?
  stroke : Stroke?
}
impl Path {
  affine_transform(Self, AffineMatrix) -> Self
  affine_transform_without_translation(Self, AffineMatrix) -> Self
  as_graphic(Self) -> Graphic
  assign_fill(Self, Fill?) -> Self
  assign_stroke(Self, Stroke?) -> Self
  assign_style(Self, Fill?, Stroke?) -> Self
  bounding_box(Self) -> BoundingBox?
  clone(Self) -> Self
  closest_point(Self, Vec2, BoundingBox?) -> Anchor?
  contains_point(Self, Vec2) -> Bool
  copy_style(Self, Graphic) -> Self
  first_styled(Self) -> Graphic?
  from_points(Array[Vec2], closed~ : Bool = ..) -> Self
  has_style(Self) -> Bool
  is_contained_by_bounding_box(Self, BoundingBox) -> Bool
  is_intersected_by_bounding_box(Self, BoundingBox) -> Bool
  is_overlapped_by_bounding_box(Self, BoundingBox) -> Bool
  loose_bounding_box(Self) -> BoundingBox?
  new(anchors~ : Array[Anchor] = .., closed~ : Bool = .., clear~ : Bool = .., fill~ : Fill? = .., stroke~ : Stroke? = ..) -> Self
  op_get(Self, Int) -> Anchor
  op_set(Self, Int, Anchor) -> Unit
  primitives(Self) -> Array[Graphic]
  remove_fill(Self) -> Self
  remove_stroke(Self) -> Self
  reverse(Self) -> Self
  rotate(Self, Double) -> Self
  scale(Self, Vec2) -> Self
  scale_stroke(Self, Double) -> Self
  style_contains_point(Self, Vec2) -> Bool
  transform(Self, position~ : Vec2 = .., rotation~ : Double = .., scale~ : Vec2 = .., skew~ : Double = .., origin~ : Vec2 = ..) -> Self
  translate(Self, Vec2) -> Self
}
impl Show for Path
impl ToJson for Path
impl @json.FromJson for Path

pub(all) struct Stroke {
  color : Color
  width : Double
  alignment : StrokeAlignment
  cap : StrokeCap
  join : StrokeJoin
  miter_limit : Double
}
impl Stroke {
  clone(Self) -> Self
  new(color~ : Color = .., width~ : Double = .., alignment~ : StrokeAlignment = .., cap~ : StrokeCap = .., join~ : StrokeJoin = .., miter_limit~ : Double = ..) -> Self
}
impl Eq for Stroke
impl Show for Stroke
impl ToJson for Stroke
impl @json.FromJson for Stroke

pub(all) enum StrokeAlignment {
  Centered
  Inner
  Outer
}
impl Eq for StrokeAlignment
impl Show for StrokeAlignment
impl ToJson for StrokeAlignment
impl @json.FromJson for StrokeAlignment

pub(all) enum StrokeCap {
  Butt
  Round
  Square
}
impl Eq for StrokeCap
impl Show for StrokeCap
impl ToJson for StrokeCap
impl @json.FromJson for StrokeCap

pub(all) enum StrokeJoin {
  Miter
  Round
  Bevel
}
impl Eq for StrokeJoin
impl Show for StrokeJoin
impl ToJson for StrokeJoin
impl @json.FromJson for StrokeJoin

pub(all) enum TextAlign {
  Left
  Center
  Right
}
impl Eq for TextAlign
impl Show for TextAlign

pub(all) struct Transform {
  position : Vec2
  rotation : Double
  scale : Vec2
  skew : Double
  origin : Vec2
}
impl Transform {
  new(position~ : Vec2 = .., rotation~ : Double = .., scale~ : Vec2 = .., skew~ : Double = .., origin~ : Vec2 = ..) -> Self
}
impl Eq for Transform
impl Show for Transform

pub(all) struct Vec2 {
  x : Double
  y : Double
}
impl Vec2 {
  add(Self, Self) -> Self
  add_scalar(Self, Double) -> Self
  affine_transform(Self, AffineMatrix) -> Self
  affine_transform_without_translation(Self, AffineMatrix) -> Self
  almost_equals(Self, Self, tolerance~ : Double = ..) -> Bool
  angle(Self) -> Double
  angle_radians(Self) -> Double
  apply(Self, (Double) -> Double) -> Self
  ceil(Self) -> Self
  clone(Self) -> Self
  copy(Self, Self) -> Self
  cross(Self, Self) -> Double
  distance(Self, Self) -> Double
  distance_squared(Self, Self) -> Double
  div(Self, Self) -> Self
  div_scalar(Self, Double) -> Self
  dot(Self, Self) -> Double
  floor(Self) -> Self
  from_angle(Double) -> Self
  from_angle_radians(Double) -> Self
  infinity() -> Self
  is_clockwise_from(Self, Self) -> Bool
  is_inf(Self) -> Bool
  is_nan(Self) -> Bool
  is_valid(Self) -> Bool
  is_zero(Self) -> Bool
  length(Self) -> Double
  length_squared(Self) -> Double
  max(Self, Self) -> Self
  min(Self, Self) -> Self
  mix(Self, Self, Double) -> Self
  mul(Self, Self) -> Self
  mul_scalar(Self, Double) -> Self
  neg_infinity() -> Self
  negate(Self) -> Self
  new(x~ : Double = .., y~ : Double = ..) -> Self
  normalize(Self) -> Self
  op_add(Self, Self) -> Self
  op_div(Self, Self) -> Self
  op_mul(Self, Self) -> Self
  op_neg(Self) -> Self
  op_sub(Self, Self) -> Self
  project_onto(Self, Self) -> Self
  rotate(Self, Double) -> Self
  rotate90(Self) -> Self
  rotate_neg90(Self) -> Self
  rotate_radians(Self, Double) -> Self
  round(Self) -> Self
  round_to_fixed(Self, Int) -> Self
  round_to_multiple(Self, Double) -> Self
  set(Self, Double, Double) -> Self
  sub(Self, Self) -> Self
  sub_scalar(Self, Double) -> Self
  transform(Self, position~ : Self = .., rotation~ : Double = .., scale~ : Self = .., skew~ : Double = .., origin~ : Self = ..) -> Self
}
impl Eq for Vec2
impl Show for Vec2
impl ToJson for Vec2
impl @json.FromJson for Vec2

// Type aliases

// Traits
trait Clonable

